### Program Order 

#### Description:  Program Order (PO) is the order in which instrudction appear in single harts dynamic execution


```yaml
1. sw t1, 0(s0)
2. sw t2, 0(s1)

3. lw a0, 0(s0)
4. lw a1, 0(s1) 

Program Order: 1->2->3->4
```

#### Preserved Program order

#### Definition: Global Memory order for any given execution of a program respects some but not all of each harts program order

#### Example: 
Consider to memory instruction **a** & **b** where **a** precedes **b** in preserved program order(& hence in GMO). 
if **a** precedes b in program order a & b both access main memory , if the following holds:

##### PPO Rules 

###### Rule 1. b is a store &  a & b accesss overlapping memory address 

```yaml
Rule 1 applie:mple of preserved program order Rule 1
        # b is a store and a and b access overlapping memory address

        .section .data
        .align 3

var:
        .dword 43
        .section .text
        .globl _start
_start:
        la t0, var
        lw a0, 0(t0)
        sw a0, 2(t0)
exit:
        li x17, 93
        ecall 

b is a store, a and b overlap - a before b in PPO
# -> hardware must not let the store become visible before the load complete
```

Rule 1 applies any time the load(a) and store(b) share at least 1 byte regardless of register width
or access size

###### Rule 2. **a** & **b** are loads, **x** is a byte read by both **a** & **b**, there is no store to **x** between **a** & **b** in 
program order and **a** & **b** return values for **x** written by different memory operations

The above is also called **Coherence for Read-Read Pairs** (CORR) rule. It ensures that the processors view of
single memory location (address) follows a logical time line

If we read a piece of data & then read it again later you are not allowed to see an "older" version of that data 
than what you saw the first time

```yaml
# hart 1 
# initial state: memory at adress (s0) contains the value 0
# context: Another hart (hart0) is simultaneously writting the value 1 to (s0)


# operation 'a' (first load) 
lw a0, 0(s0) # read at address x we see the new valu e


# no store 

lw a1, 0(s0) # Read address x again 
```

a. **a** and **b** are loads 
b. **x** is a byte read by both **a** and **b**. Both instructions read 4 bytes from 
the address in s0
c. There is no store to x between **a** and **b**
d. **a** and **b** return values for x written by different memory operations


Forbidden outcome: If the processor were allowed to execute **load b** before **load a**
out of order, the following sequence could happen  in global memory timeline

1. Hart 1 executes **b**: Reads 0 (the old initial initial value) 
2. Hart 0 executes store: writes 1 (the new value)
3. Hart 1 executes **a**: Reads 1 (the new value)


The above would  imply that time moved backwards and we saw the future and then immediately saw
the past. **Rule 2** prohibits this and mandates that if **a** precedes **b** in program order and 
they see different writes, **a** must preceede **b** in the global memory order.

###### Rule 3. a is a generated by AMO or SC instructions. b is a load and b returns a value written by a

This rule is also called **Store to load forwarding for atomic**

when we execute a normal store (sw), the data goes to private store buffer, if we immediately load (lw) from that
same address, the CPU allows to peek in to your own store buffer and get value back instantly, even before the store has 
reached main memory or become visible other cores

Rule 3 disables private peeking optimization for **AMO** and **sc**. It states that:

a. instruction **a** is an atomic memory operation (AMO) or store conditional (sc)

b. Instruction b is a load 

c. And **b** returns the value written by **atomic a**

Then **a** must be globally visible to the entire system before b is allowed to return that value

The processor cannot simply forwared the data locally inside the pipeline, the AMO must essentially **complete**
it's interaction with memory system bfore you can read its result back 

```yaml
        .section .data
n1:
        .long 42, 43

        .section .text
        .globl _start
_start:
        lui t0, %hi(n1)
        addi t0, t0, %lo(n1)
        li a0, 0

        lw t1, 0(t0)
        lw t2, 4(t0)

        # the below instruction causes the value 43
        # be stored in memory and will not run
        # lw instruction until the value is committed
        # to memory
        amoswap.w t1, t2, (t0)
        lw a0, 0(t0)


exit:
        li x17,93
        ecall

```
